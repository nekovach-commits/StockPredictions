<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Stock Viewer - Plotly</title>
    <style>
        body { font-family: Segoe UI, Roboto, Arial, sans-serif; margin: 16px; }
        #controls { margin-bottom: 12px; }
        #chartContainer { height: 640px; max-width: 1200px; margin: 0 auto; }
        .hint { color: #444; font-size: 0.95rem; margin-top: 6px; }
        input[type="text"] { padding: 6px; font-size: 1rem; width: 160px; }
        button { padding: 6px 10px; font-size: 1rem; }
        #chart { width: 100%; height: 640px; }
    </style>
    <script src="https://cdn.plot.ly/plotly-2.20.0.min.js"></script>
</head>
<body>
    <h2><a href='https://nekovach-commits.github.io/StockPredictions/StockGainLossReport.html'>Stock Viewer</a></h2>
    <div id="controls">
        <label for="stockInput">Stock symbol:</label>
        <input id="stockInput" type="text" value="TSLA" />
        <button id="loadBtn">Load</button>
    </div>

    <div id="chartContainer"><div id="chart">Loading...</div></div>
    <div id="status" class="hint"></div>

    <script>
        function parseCsv(text) {
            const lines = text.split(/\r?\n/).map(l => l.trim()).filter(l => l.length > 0);
            if (lines.length <= 1) return [];
            const rows = [];
            for (let i = 1; i < lines.length; i++) {
                const parts = lines[i].split(',').map(p => p.trim().replace(/^"|"$/g, ''));
                rows.push(parts);
            }
            return rows;
        }

        function parseIsoDate(s) {
            if (!s) return null;
            const m = s.trim().match(/^(\d{4})-(\d{1,2})-(\d{1,2})$/);
            if (!m) return s;
            const year = parseInt(m[1], 10);
            const month = ('0' + m[2]).slice(-2);
            const day = ('0' + m[3]).slice(-2);
            return `${year}-${month}-${day}`; // Plotly accepts ISO date strings
        }

        async function fetchText(url) {
            const res = await fetch(url);
            if (!res.ok) throw new Error(`Failed to fetch ${url}: ${res.status}`);
            return await res.text();
        }

        function buildCandlestick(rows) {
            const dates = [], open = [], high = [], low = [], close = [];
            for (const r of rows) {
                if (r.length < 5) continue;
                const d = parseIsoDate(r[0]);
                const o = parseFloat(r[1]);
                const h = parseFloat(r[2]);
                const l = parseFloat(r[3]);
                const c = parseFloat(r[4]);
                if (!d || isNaN(o) || isNaN(h) || isNaN(l) || isNaN(c)) continue;
                dates.push(d);
                open.push(o); high.push(h); low.push(l); close.push(c);
            }
            return { dates, open, high, low, close };
        }

        function buildRange(rows) {
            const dates = [], highs = [], lows = [];
            for (const r of rows) {
                if (r.length < 3) continue;
                const d = parseIsoDate(r[0]);
                const h = parseFloat(r[1]);
                const l = parseFloat(r[2]);
                if (!d || isNaN(h) || isNaN(l)) continue;
                dates.push(d); highs.push(h); lows.push(l);
            }
            return { dates, highs, lows };
        }

        function renderPlot(stock, histRange, candle, forecast) {
            const traces = [];

            if (histRange.dates.length > 0) {
                traces.push({ x: histRange.dates, y: histRange.lows, mode: 'lines', line: { width: 0 }, hoverinfo: 'skip', showlegend: false });
                traces.push({ x: histRange.dates, y: histRange.highs, mode: 'lines', line: { color: 'rgba(30,144,255,0.0)', width: 0 }, fill: 'tonexty', fillcolor: 'rgba(30,144,255,0.18)', name: 'Historical Range', hovertemplate: 'High: %{y:.2f}<extra></extra>' });
            }

            if (candle.dates.length > 0) {
                traces.push({ x: candle.dates, open: candle.open, high: candle.high, low: candle.low, close: candle.close, increasing: { line: { color: 'green' } }, decreasing: { line: { color: 'red' } }, type: 'candlestick', name: 'Predicted (O/H/L/C)' });
            }

            const allDates = [].concat(histRange.dates || [], candle.dates || []).filter(d => d);
            let tick0 = null;
            if (allDates.length > 0) {
                const ms = allDates.map(d => new Date(d).getTime());
                tick0 = Math.min.apply(null, ms);
            }

            const layout = {
                title: `Stock: ${stock}`,
                xaxis: { type: 'date', tickformat: '%m-%d', tickangle: -45, dtick: 24 * 3600 * 1000, tick0: tick0, rangeslider: { visible: false } },
                yaxis: { tickprefix: '$', autorange: true },
                margin: { t: 40 }
            };

            let minY = Number.POSITIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;
            histRange.lows.forEach(v => { if (!isNaN(v)) minY = Math.min(minY, v); });
            histRange.highs.forEach(v => { if (!isNaN(v)) maxY = Math.max(maxY, v); });
            candle.low.forEach(v => { if (!isNaN(v)) minY = Math.min(minY, v); });
            candle.high.forEach(v => { if (!isNaN(v)) maxY = Math.max(maxY, v); });
            if (!isFinite(minY) || !isFinite(maxY)) { minY = null; maxY = null; }

            const shapes = [];
            const annotations = [];
            if (forecast && minY !== null) {
                const addShape = (value, color, text) => {
                    if (value === null || value === undefined || isNaN(value)) return;
                    if (value < minY || value > maxY) return;
                    shapes.push({ type: 'line', xref: 'paper', x0: 0, x1: 1, yref: 'y', y0: value, y1: value, line: { color: color, width: 2, dash: 'dash' } });
                    annotations.push({ xref: 'paper', x: 1.01, y: value, xanchor: 'left', yanchor: 'middle', text: `${text}: $${value.toFixed(2)}`, showarrow: false, font: { color: color } });
                };
                addShape(forecast.High, 'green', 'Forecast High');
                addShape(forecast.Median, 'black', 'Forecast Median');
                addShape(forecast.Low, 'red', 'Forecast Low');
            }
            if (shapes.length) layout.shapes = shapes;
            if (annotations.length) layout.annotations = (layout.annotations || []).concat(annotations);

            Plotly.newPlot('chart', traces, layout, {responsive: true});
        }

        async function loadForStock(stock) {
            const status = document.getElementById('status');
            const chart = document.getElementById('chart');
            chart.innerHTML = 'Loading...';
            status.textContent = '';

            const dataUrl = `${encodeURIComponent(stock)}data.csv`;
            const histUrl = `${encodeURIComponent(stock)}hist.csv`;
            const forecastUrl = `${encodeURIComponent(stock)}_PHPforecast.txt`;

            try {
                const [dataText, histText] = await Promise.all([fetchText(dataUrl), fetchText(histUrl)]);

                let forecast = null;
                try {
                    const fText = await fetchText(forecastUrl);
                    const fLines = fText.split(/\r?\n/).map(l => l.trim()).filter(l => l.length > 0);
                    if (fLines.length >= 2) {
                        const parts = fLines[1].split(',').map(p => p.trim());
                        const h = parseFloat(parts[0]);
                        const m = parseFloat(parts[1]);
                        const l = parseFloat(parts[2]);
                        // use null for missing values so zero is treated as valid
                        forecast = { High: isNaN(h) ? null : h, Median: isNaN(m) ? null : m, Low: isNaN(l) ? null : l };
                    }
                } catch (e) { forecast = null; }

                const predRows = parseCsv(dataText);
                const histRows = parseCsv(histText);

                const candle = buildCandlestick(predRows);
                const histRange = buildRange(histRows);

                if (candle.dates.length === 0 && histRange.dates.length === 0) {
                    chart.innerHTML = 'No valid data found in CSVs.';
                    status.textContent = `Tried: ${dataUrl}, ${histUrl}`;
                    return;
                }

                renderPlot(stock, histRange, candle, forecast);
                status.textContent = `Loaded: ${dataUrl} (${candle.dates.length} rows), ${histUrl} (${histRange.dates.length} rows)` + (forecast ? `; Forecast H/M/L=${forecast.High}/${forecast.Median}/${forecast.Low}` : '');
            } catch (err) {
                chart.innerHTML = 'Error loading CSVs. See Status below.';
                status.textContent = err.message;
            }
        }

        (function init() {
            const stockInput = document.getElementById('stockInput');
            const loadBtn = document.getElementById('loadBtn');

            loadBtn.addEventListener('click', () => {
                const s = (stockInput.value||'').trim().toUpperCase();
                if (!s) return alert('Enter a stock symbol first.');
                loadForStock(s);
            });

            // determine initial symbol: prefer ?stock= param
            let initial = 'TSLA';
            try {
                const params = new URLSearchParams(window.location.search);
                const q = params.get('stock');
                if (q && q.trim().length > 0) {
                    initial = q.trim().toUpperCase();
                }
            } catch (e) {
                // ignore and use default
            }

            stockInput.value = initial;
            loadForStock(initial);
        })();
    </script>
</body>
</html>
