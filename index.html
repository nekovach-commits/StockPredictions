<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Stock Viewer - Chart.js</title>
    <style>
        body {
            font-family: Segoe UI, Roboto, Arial, sans-serif;
            margin: 16px;
        }

        #controls {
            margin-bottom: 12px;
        }

        #chartContainer {
            height: 640px;
            max-width: 1200px;
            margin: 0 auto;
        }

        .hint {
            color: #444;
            font-size: 0.95rem;
            margin-top: 6px;
        }

        input[type="text"] {
            padding: 6px;
            font-size: 1rem;
            width: 160px;
        }

        button {
            padding: 6px 10px;
            font-size: 1rem;
        }

        canvas {
            width: 100% !important;
            height: 640px !important;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/date-fns@2.29.3/dist/date-fns.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@2.0.0/dist/chartjs-adapter-date-fns.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-financial@3.3.0/dist/chartjs-chart-financial.min.js"></script>
</head>
<body>
    <h2>Stock Viewer (Chart.js)</h2>
    <div id="controls">
        <label for="stockInput">Stock symbol:</label>
        <input id="stockInput" type="text" placeholder="e.g. TSLA" />
        <button id="loadBtn">Load</button>
        <button id="openNewTabBtn">Open ?stock URL</button>
        <div class="hint">Tip: you can also load this page with <code>?stock=SYMBOL</code> (example: <code>index.html?stock=TSLA</code>).</div>
    </div>

    <div id="chartContainer"><canvas id="chartCanvas"></canvas></div>
    <div id="status" class="hint"></div>

    <script>
        // Utility: get query param
        function getQueryParam(name) {
            const params = new URLSearchParams(window.location.search);
            return params.get(name);
        }

        // Naive CSV parser for simple CSVs used by the app (no quoted commas expected)
        function parseCsv(text) {
            const lines = text.split(/\r?\n/).map(l => l.trim()).filter(l => l.length > 0);
            if (lines.length <= 1) return [];
            const rows = [];
            for (let i = 1; i < lines.length; i++) {
                const parts = lines[i].split(',').map(p => p.trim().replace(/^"|"$/g, ''));
                rows.push(parts);
            }
            return rows;
        }

        // Parse ISO date 'YYYY-MM-DD' reliably across browsers
        function parseIsoDate(s) {
            if (!s) return null;
            const m = s.trim().match(/^(\d{4})-(\d{1,2})-(\d{1,2})$/);
            if (!m) return new Date(s); // fallback
            const year = parseInt(m[1], 10);
            const month = parseInt(m[2], 10) - 1;
            const day = parseInt(m[3], 10);
            return new Date(year, month, day);
        }

        async function fetchText(url) {
            const res = await fetch(url);
            if (!res.ok) throw new Error(`Failed to fetch ${url}: ${res.status}`);
            return await res.text();
        }

        function buildCandlestickPoints(rows) {
            // returns array of {x: Date, o:, h:, l:, c:}
            const pts = [];
            for (const r of rows) {
                if (r.length < 5) continue;
                const d = parseIsoDate(r[0]);
                const open = parseFloat(r[1]);
                const high = parseFloat(r[2]);
                const low = parseFloat(r[3]);
                const close = parseFloat(r[4]);
                if (!d || isNaN(d.getTime()) || isNaN(open) || isNaN(high) || isNaN(low) || isNaN(close)) continue;
                pts.push({ x: d.getTime(), o: open, h: high, l: low, c: close });
            }
            pts.sort((a, b) => a.x - b.x);
            return pts;
        }

        function buildRangePoints(rows) {
            // returns two arrays: lows and highs as {x: timestamp, y: value}
            const lows = [];
            const highs = [];
            for (const r of rows) {
                if (r.length < 3) continue;
                const d = parseIsoDate(r[0]);
                const high = parseFloat(r[1]);
                const low = parseFloat(r[2]);
                if (!d || isNaN(d.getTime()) || isNaN(high) || isNaN(low)) continue;
                const t = d.getTime();
                lows.push({ x: t, y: low });
                highs.push({ x: t, y: high });
            }
            lows.sort((a, b) => a.x - b.x);
            highs.sort((a, b) => a.x - b.x);
            return { lows, highs };
        }

        function computeYRangeFromData(lows, highs, candlesticks) {
            let minY = Number.POSITIVE_INFINITY;
            let maxY = Number.NEGATIVE_INFINITY;
            for (const p of lows) { if (!isNaN(p.y)) minY = Math.min(minY, p.y); }
            for (const p of highs) { if (!isNaN(p.y)) maxY = Math.max(maxY, p.y); }
            for (const c of candlesticks) {
                if (!isNaN(c.l)) minY = Math.min(minY, c.l);
                if (!isNaN(c.h)) maxY = Math.max(maxY, c.h);
            }
            if (!isFinite(minY) || !isFinite(maxY)) return null;
            return { minY, maxY };
        }

        let chartInstance = null;

        function renderChart(stock, histRanges, candlesticks, forecast) {
            const ctx = document.getElementById('chartCanvas').getContext('2d');
            if (chartInstance) chartInstance.destroy();

            const lows = histRanges.lows;
            const highs = histRanges.highs;
            const yRange = computeYRangeFromData(lows, highs, candlesticks);

            // compute x domain for optional horizontal lines
            const allX = [];
            lows.forEach(p => allX.push(p.x));
            highs.forEach(p => allX.push(p.x));
            candlesticks.forEach(c => allX.push(c.x));
            const minX = Math.min(...allX);
            const maxX = Math.max(...allX);

            const datasets = [];

            // historical low (plotted first)
            datasets.push({
                label: 'Historical Low',
                data: lows,
                borderColor: 'rgba(30,144,255,0.0)',
                backgroundColor: 'rgba(30,144,255,0.0)',
                pointRadius: 0,
                borderWidth: 0,
                fill: false,
                showLine: true
            });

            // historical high (plotted second) - fill to previous to create area
            datasets.push({
                label: 'Historical High',
                data: highs,
                borderColor: 'rgba(30,144,255,0.0)',
                backgroundColor: 'rgba(30,144,255,0.18)',
                pointRadius: 0,
                borderWidth: 0,
                fill: '-1',
                showLine: true
            });

            // candlestick series using financial plugin
            datasets.push({
                label: 'Predicted (O,H,L,C)',
                type: 'candlestick',
                data: candlesticks,
                borderColor: 'rgba(0,0,0,0.8)'
            });

            // forecast horizontal lines as line datasets spanning minX..maxX
            if (forecast && yRange) {
                const { minY, maxY } = yRange;
                const addIfVisible = (value, color, label) => {
                    if (!value || isNaN(value)) return;
                    if (value < minY || value > maxY) return;
                    datasets.push({
                        label: label,
                        data: [{ x: minX, y: value }, { x: maxX, y: value }],
                        borderColor: color,
                        borderWidth: 1.5,
                        pointRadius: 0,
                        type: 'line',
                        fill: false,
                        borderDash: [6, 4]
                    });
                };
                addIfVisible(forecast.High, 'rgba(0,128,0,0.9)', 'Forecast High');
                addIfVisible(forecast.Median, 'rgba(0,0,0,0.9)', 'Forecast Median');
                addIfVisible(forecast.Low, 'rgba(255,0,0,0.9)', 'Forecast Low');
            }

            chartInstance = new Chart(ctx, {
                data: { datasets },
                options: {
                    interaction: { mode: 'nearest', intersect: false },
                    plugins: {
                        legend: { display: true }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: { unit: 'day' }
                        },
                        y: {
                            ticks: { callback: (v) => '$' + v },
                            beginAtZero: false
                        }
                    }
                }
            });
        }

        async function loadForStock(stock) {
            const status = document.getElementById('status');
            const chartContainer = document.getElementById('chartContainer');
            chartContainer.innerHTML = '<canvas id="chartCanvas"></canvas>';
            status.textContent = '';

            const dataUrl = `${encodeURIComponent(stock)}data.csv`;
            const histUrl = `${encodeURIComponent(stock)}hist.csv`;
            const forecastUrl = `${encodeURIComponent(stock)}_PHPforecast.txt`;

            try {
                const [dataText, histText] = await Promise.all([
                    fetchText(dataUrl),
                    fetchText(histUrl)
                ]);

                // try forecast but it's optional
                let forecast = null;
                try {
                    const fText = await fetchText(forecastUrl);
                    const fLines = fText.split(/\r?\n/).map(l => l.trim()).filter(l => l.length > 0);
                    if (fLines.length >= 2) {
                        const parts = fLines[1].split(',').map(p => p.trim());
                        const h = parseFloat(parts[0]);
                        const m = parseFloat(parts[1]);
                        const l = parseFloat(parts[2]);
                        forecast = { High: isNaN(h) ? 0 : h, Median: isNaN(m) ? 0 : m, Low: isNaN(l) ? 0 : l };
                    }
                } catch (e) {
                    forecast = null;
                }

                const predRows = parseCsv(dataText);
                const histRows = parseCsv(histText);

                const candlesticks = buildCandlestickPoints(predRows);
                const histRanges = buildRangePoints(histRows);

                if (candlesticks.length === 0 && histRanges.lows.length === 0) {
                    chartContainer.innerHTML = 'No valid data found in CSVs.';
                    status.textContent = `Tried: ${dataUrl}, ${histUrl}`;
                    return;
                }

                renderChart(stock, histRanges, candlesticks, forecast);
                status.textContent = `Loaded: ${dataUrl} (${candlesticks.length} rows), ${histUrl} (${histRanges.lows.length} rows)` + (forecast ? `; Forecast H/M/L=${forecast.High}/${forecast.Median}/${forecast.Low}` : '');
            } catch (err) {
                chartContainer.innerHTML = 'Error loading CSVs. See status below.';
                status.textContent = err.message;
            }
        }

        // Wire up UI
        (function init() {
            const stockInput = document.getElementById('stockInput');
            const loadBtn = document.getElementById('loadBtn');
            const openNewTabBtn = document.getElementById('openNewTabBtn');

            // load from query string if present
            const qStock = getQueryParam('stock');
            if (qStock) {
                stockInput.value = qStock.toUpperCase();
                loadForStock(stockInput.value);
            }

            loadBtn.addEventListener('click', () => {
                const s = (stockInput.value || '').trim().toUpperCase();
                if (!s) return alert('Enter a stock symbol first.');
                loadForStock(s);
            });

            openNewTabBtn.addEventListener('click', () => {
                const s = (stockInput.value || '').trim().toUpperCase();
                if (!s) return alert('Enter a stock symbol first.');
                const url = `${location.pathname}?stock=${encodeURIComponent(s)}`;
                window.open(url, '_blank');
            });
        })();
    </script>
</body>
</html>
